软件的定义	1-4
基于构件组装	1-5
磨损	1-5
软件的特征	1-5
定制软件	1-5
故障曲线	1-7
硬件故障曲线	1-7
浴缸曲线	1-7
软件故障曲线	1-8
软件的分类	1-10
软件面临的新挑战	1-11
项目规模	1-12
软件复杂性	1-13
软件危机的表现	1-15
成功率	1-16
项目成功率	1-16
软件实践的问题	1-17
实践的问题	1-17
软件事故	1-18
事故	1-18
产业现状	1-19
软件产业现状	1-19
中国的软件产业现状	1-19
软件危机的原因	1-20
管理人员的误区	1-22
软件误区	1-22
误区	1-22
客户的误区	1-23
开发人员的误区	1-24
工程定义	1-27
良好的工程	1-28
定义	1-30
软件工程定义	1-30
软件工程战略性学科	1-33
战略性学科	1-33
核心准则	1-34
软件工程核心准则	1-34
复杂性	1-35
控制复杂性	1-35
SWEBOK	1-37
软件过程知识体系	1-37
知识体系	1-37
金三角	1-38
管理活动	1-39
活动	1-39
技术活动	1-39
系统工程	1-40
需求	1-41
需求	1-42
设计	1-42
设计	1-43
编程	1-44
编程的误区	1-45
误区（编程）	1-45
测试	1-46
部署	1-47
分配比例	1-48
工作量分配比例	1-48
维护	1-49
运行	1-49
费用分配比例	1-50
分配比例	1-50
纠错性维护	1-51
适应性维护	1-51
完善性维护	1-51
维护类型	1-51
预防性维护	1-51
发展	1-52
波音747	1-56
模型	1-59
模型的定义	1-59
模型的功能	1-61
建模	1-62
建模的重要性	1-62
模型的特征	1-63
有用模型的特征	1-63
模型的多个视图	1-64
视图	1-64
UML软件模型视图	1-65
CIM	1-66
PIM	1-66
PSM	1-66
计算无关模型	1-66
平台无关模型	1-66
特定平台模型	1-66
模型的转换	1-67
建模的方法	1-68
形式化方法	1-69
结构化方法	1-72
面向对象方法	1-73
UML模型	1-74
UML建模工具	1-75
杠杆作用点	2-4
软件过程的杠杆作用点	2-4
作用点	2-4
软件过程	2-5
软件过程组成	2-6
软件开发模型	2-8
软件生存周期模型	2-8
生存周期模型	2-8
瀑布型	2-10
线性顺序模型	2-10
增量型	2-14
演化型	2-17
演化型类型	2-17
最广泛的模型	2-19
快速原型模型	2-21
螺旋模型	2-24
喷泉模型	2-25
专用过程模型	2-27
模型驱动开发	2-27
构件	2-28
基于构件的开发	2-29
净室软件工程	2-30
形式化方法模型	2-30
面向方面软件开发	2-33
CIM	2-35
PIM	2-35
PSM	2-35
计算无关模型	2-35
平台无关模型	2-35
特定平台模型	2-35
RUP	2-37
风险驱动	2-37
统一软件过程	2-37
阶段	2-38
迭代	2-39
需求工程	3-4
需求定义	3-6
功能需求	3-7
Functionality	3-7
FURPS	3-8
URPS	3-8
非功能需求	3-8
可靠性	3-9
Reliability	3-9
支持性	3-10
Supportability	3-10
性能需求	3-11
Performance	3-11
可用性	3-12
Usability	3-12
设计约束	3-13
软件需求规约	3-14
涉众需求	3-14
项目前景文档	3-14
需求驱动开发	3-15
需求具有的特性	3-17
二义性	3-18
无二义性	3-18
可理解性	3-20
可验证性	3-21
可验证性	3-21
需求出错	3-22
需求获取	3-24
IT黑洞	3-26
Yes... But现象	3-26
解决方案	3-27
业务解决方案	3-27
Vision	3-29
前景文档	3-29
系统工程	3-30
涉众定义	3-31
项目的约束	3-33
约束	3-33
常用术语	3-35
术语	3-35
术语表	3-35
需求的来源	3-38
需求收集	3-39
需求获取	3-40
分析建模准则	3-44
PIM	3-45
分析模型	3-45
平台无关模型	3-45
结构化的分析模型	3-46
面向对象的分析模型	3-47
SRS	3-50
Vision	3-50
概要需求	3-50
详细需求	3-50
需求定义	3-50
前景文档	3-51
产品定位	3-52
产品特性	3-53
质量范围	3-54
文档需求	3-55
项目范围	3-56
特性的优先级	3-57
软件需求规约	3-59
细化需求	3-60
接口设计	3-61
设计接口	3-61
设计用户界面	3-61
用户界面设计	3-61
描述用户界面	3-62
用户界面描述	3-62
SRS模板	3-63
传统技术SRS模板	3-63
Use-Case技术SRS模板	3-64
需求验证	3-65
评审方法	3-66
需求评审	3-67
需求管理	3-70
变更控制程序	3-71
需求变更管理	3-71
需求跟踪	3-72
Object Technology	4.2-3
对象技术	4.2-3
面向对象分析	4.2-7
Object-orientation	4.2-7
OO	4.2-7
UML历史	4.2-8
面向对象	4.2-9
面向对象步骤	4.2-9
对象定义	4.2-12
UML对象表达	4.2-14
对象表达UML	4.2-14
面向对象的基本原则	4.2-15
Abstraction	4.2-16
抽象	4.2-16
Encapsulation	4.2-18
封装	4.2-18
Modularity	4.2-20
模块化	4.2-20
对象层次	4.2-22
Hierarchy	4.2-22
Class	4.2-23
类定义	4.2-23
UML类表达	4.2-24
类表达UML	4.2-24
对象-类关系	4.2-25
类-对象关系	4.2-25
Package	4.2-26
包定义	4.2-26
Use-Case 技术	4.2-29
用例技术	4.2-29
Use-Case	4.2-29
用例	4.2-29
Use-Case模型组成	4.2-30
用例模型组成	4.2-30
Use-Case建模步骤	4.2-31
用例建模步骤	4.2-31
Use-Case建模步骤	4.2-31
Actor 定义	4.2-33
参与者 定义	4.2-33
Actor 识别	4.2-34
参与者 识别	4.2-34
Use-Case识别	4.2-34
用例识别	4.2-34
Communications-Association	4.2-37
通信-关联	4.2-37
Use-Case Specification	4.2-40
用例规约	4.2-40
Alternative Flow	4.2-41
Basic Flow	4.2-41
备选流	4.2-41
基本流	4.2-41
事件流	4.2-41
书写用例	4.2-42
Scenario	4.2-43
方案	4.2-43
Activity Diagram	4.2-48
活动图	4.2-48
Partitions	4.2-50
泳道	4.2-50
前置条件	4.2-51
后置条件	4.2-52
Use-case图	4.2-53
活动图	4.2-53
交互图	4.2-53
扩展点	4.2-53
特殊需求 (用例)	4.2-53
用户界面框图	4.2-53
Use-Case间的关系	4.2-55
关系 (用例)	4.2-55
Include (Use-Case)	4.2-57
包含 (用例)	4.2-57
Extend (Use-Case)	4.2-59
扩展 (用例)	4.2-59
Generalization (Use-Case)	4.2-63
泛化 (用例)	4.2-63
Generalization (Actor)	4.2-65
泛化 (参与者)	4.2-65
Class Diagram	4.2-68
类图	4.2-68
概念模型	4.2-71
Conceptual Model	4.2-71
Conceptual Class	4.2-72
概念类	4.2-72
类 关系	4.2-78
关系 (类)	4.2-78
Relationship (Class)	4.2-78
Class (Relationship)	4.2-78
Association	4.2-79
关联关系	4.2-79
Multiplicity	4.2-80
多重度	4.2-80
Role (Class Diagram)	4.2-84
角色 (类图)	4.2-84
Navigability	4.2-85
导览	4.2-85
Aggregation	4.2-87
聚合关系	4.2-87
Generalization (Class)	4.2-89
泛化 (类)	4.2-89
Composition	4.2-89
合成关系	4.2-89
Aggregation	4.2-90
聚合关系	4.2-90
Composition	4.2-90
合成关系	4.2-90
Single Inheritance	4.2-94
单继承	4.2-94
Multiple Inheritance	4.2-95
多继承	4.2-95
Inherit	4.2-96
继承	4.2-96
Aggregation	4.2-98
聚合关系	4.2-98
Factoring	4.2-102
分解	4.2-102
Delegation	4.2-103
委派	4.2-103
Implementation Inheritance	4.2-104
继承 实现	4.2-104
Liskov替换原则	4.2-105
LSP	4.2-105
Dependency	4.2-108
依赖关系	4.2-108
Association	4.2-109
关联关系	4.2-109
Visibility	4.2-110
可见度	4.2-110
Use-Case Realization	4.2-116
用例实现	4.2-116
分析类	4.2-117
Analysis Class	4.2-117
Entity Class	4.2-118
实体类	4.2-118
Boundary Class	4.2-121
边界类	4.2-121
Control Class	4.2-124
控制类	4.2-124
行为建模	4.2-128
Collaborate	4.2-129
协作	4.2-129
Messages	4.2-130
消息	4.2-130
Interaction Diagram	4.2-131
交互图	4.2-131
Sequence Diagram	4.2-133
时序图	4.2-133
Communication Diagram	4.2-136
通信图	4.2-136
类 操作	4.2-139
类 关系	4.2-139
操作 (类)	4.2-139
关系 (类)	4.2-139
Relationship (Class)	4.2-139
Operation (Class)	4.2-139
Class (Relationship)	4.2-139
Class (Operation)	4.2-139
泛化 (类的关系)	4.2-
设计工程	5-1
设计模型	5-5
类设计	5-6
数据设计	5-6
架构风格	5-7
设计模式	5-7
架构设计	5-7
可靠性	5-8
可用性	5-8
性能	5-8
易用性	5-8
质量因素	5-8
安全性	5-9
可测试性	5-9
可维护性	5-9
接口设计	5-12
构件级设计	5-13
抽象 (设计)	5-15
数据抽象	5-16
过程抽象	5-17
逐步求精	5-18
模块化	5-19
分解	5-20
信息隐藏	5-22
模块独立	5-23
内聚 (定义)	5-24
耦合 (定义)	5-24
内聚 (级别)	5-25
耦合 (级别)	5-26
模块的优劣标准	5-27
设计质量	5-29
质量	5-29
设计评审	5-31
重构	5-32
Refactoring	5-32
Design Reuse	5-34
Reuse	5-34
复用	5-34
设计复用	5-34
重用	5-34
设计重用	5-34
模式	5-35
软件模式	5-35
Architectural Patten	5-37
Design Pattern	5-37
Idiom	5-37
架构模式	5-37
设计模式	5-37
成例	5-37
分层模式	5-38
Layers模式	5-38
Blackboard模式	5-38
黑板模式	5-38
Broker模式	5-38
分布式系统	5-38
Distributed System	5-38
架构风格	5-38
交互系统	5-39
Interactive System	5-39
MVC	5-39
Model-View-Controller	5-39
Presentation-abstraction-control 	5-39
PAC	5-39
Adaptable System	5-39
适应系统	5-39
微内核	5-39
Microkernel	5-39
MVC	5-40
Layered Architecture	5-41
层次架构风格	5-41
Pipes and Filters	5-43
管道和过滤器风格	5-43
Blackboard	5-44
黑板风格	5-44
Design Pattern	5-45
设计模式	5-45
GoF	5-46
Gang of Four	5-46
外观模式	5-47
Façade Pattern	5-47
Framework	5-49
框架	5-49
MVC框架	5-50
ORM框架	5-50
复合框架	5-50
界面框架	5-50
JSP Model II	5-52
J2EE	5-53
Struts	5-54
JSF	5-55
分析模型	6.2-3
设计模型	6.2-3
面向对象设计	6.2-4
Class	6.2-6
类	6.2-6
Design Classes	6.2-7
设计类	6.2-7
Interface	6.2-9
Subsystem	6.2-9
接口	6.2-9
子系统	6.2-9
Package	6.2-11
包	6.2-11
4+1 View	6.2-17
4+1 视图	6.2-17
Logical View	6.2-18
逻辑视图	6.2-18
架构风格	6.2-19
Layering Approach	6.2-20
分层	6.2-20
Architectural Layer	6.2-21
Partitioning	6.2-23
Application Layer	6.2-25
应用层	6.2-25
Business Services Layer	6.2-26
业务服务层	6.2-26
设计模式	6.2-28
Persistence Design Pattern	6.2-30
持久设计模式	6.2-30
JDBC	6.2-31
Process View	6.2-37
Process	6.2-38
Thread	6.2-38
进程	6.2-38
线程	6.2-38
Deployment View	6.2-40
部署视图	6.2-40
Distribution Patterns	6.2-42
分布模式	6.2-42
C/S 架构	6.2-43
Client/Server Architectures	6.2-43
节点 (部署视图)	6.2-44
Node (Deployment View)	6.2-44
Connector	6.2-45
联结器	6.2-45
Implementation View	6.2-48
实现视图	6.2-48
Component Diagram	6.2-49
构件图	6.2-49
Component	6.2-50
构件	6.2-50
Data View	6.2-52
数据视图	6.2-52
Relational Data Model	6.2-53
关系数据模型	6.2-53
OR Mapping	6.2-55
OR映射	6.2-55
构件级设计	6.2-57
Subsystem Interactions	6.2-63
子系统接口	6.2-63
子系统设计	6.2-65
优化类	6.2-68
Boundary Class	6.2-69
用户界面类	6.2-69
UI类	6.2-69
边界类	6.2-69
Web页面建模	6.2-70
建模Web页面	6.2-70
Control Class	6.2-71
控制类	6.2-71
Entity Class	6.2-72
实体类	6.2-72
Operation Signature	6.2-73
操作签名	6.2-73
State	6.2-75
状态	6.2-75
State Machine Diagram	6.2-76
状态机图	6.2-76
Special State	6.2-77
Initial State	6.2-77
Final State	6.2-77
特殊状态	6.2-77
初始状态	6.2-77
最终状态	6.2-77
唱片播放器	6.2-79
Activity (State)	6.2-80
Action （State)	6.2-80
活动 (状态机图)	6.2-80
动作 (状态机图)	6.2-80
关键状态	6.2-83
Significant State	6.2-83
Attribute Representation	6.2-84
属性表示	6.2-84
Association Class	6.2-86
关联类	6.2-86
Forward Engineering	6.2-87
Reverse Engineering	6.2-87
Round-Trip Engineering	6.2-87
逆向工程	6.2-87
双向工程	6.2-87
正向工程	6.2-87
用户界面	7-1
技术实现 (界面)	7-2
艺术设计 (界面)	7-2
易用性设计 (界面)	7-2
界面设计 典型错误	7-3
消息框	7-4
教育 (界面)	7-5
服务对象 (界面)	7-5
黄金规则 (界面)	7-7
界面设计 黄金规则	7-7
驾驭软件 (界面)	7-8
记忆 (界面)	7-9
一致性 (界面)	7-10
风格 (界面)	7-13
界面设计风格	7-13
字符用户界面	7-14
Graphics User Interface	7-15
GUI	7-15
图形用户界面	7-15
多媒体用户界面	7-16
Multimodal User Interface	7-17
多通道用户界面	7-17
界面设计模式	7-18
模型 (界面)	7-21
界面设计模型	7-21
界面设计过程	7-22
用户分类 (界面)	7-23
外行型	7-23
初学型	7-23
熟练型	7-23
专家型	7-23
界面设计要素	7-26
Response time	7-27
系统响应时间	7-27
Help facility	7-28
求助设施	7-28
操作信息反馈	7-29
反馈操作信息	7-29
Error handling	7-31
出错处理	7-31
防错处理	7-32
Menu	7-33
Command Labeling	7-33
命令标记	7-33
菜单	7-33
布局	7-34
色彩	7-35
Internationalization	7-37
国际化	7-37
Ada	8-5
C	8-5
C++	8-5
Eiffel	8-5
FORTRAN	8-5
Haskell	8-5
Id	8-5
Java	8-5
LISP	8-5
ML	8-5
Prolog	8-5
Scheme	8-5
Smalltalk	8-5
Spreedsheets	8-5
Val	8-5
XSLT	8-5
高级程序设计语言	8-5
函数式语言	8-5
基于约束的语言	8-5
逻辑式语言	8-5
命令式语言	8-5
数据流语言	8-5
说明式语言	8-5
模板 (语言)	8-5
冯诺依曼语言	8-5
面向对象语言	8-5
ALGO	8-6
APL	8-6
Assembler	8-6
BASIC	8-6
COBOL	8-6
Forth	8-6
Modula	8-6
PL/I	8-6
SNOBOL	8-6
应用领域 （语言)	8-6
Script Language	8-7
脚本语言	8-7
Awk	8-8
Bash	8-8
CSH	8-8
Shell	8-8
Perl	8-9
PHP	8-9
JavaScript	8-10
Python	8-10
Tcl	8-10
Ruby	8-11
选择语言	8-12
语言选择	8-12
编码准则	8-15
编码的风格	8-18
GOTO 语句	8-19
Code Documentation	8-22
文档化	8-22
源程序的文档化	8-22
正向工程	8-24
逆向工程	8-24
Forward Engineering	8-24
Reverse Engineering	8-24
Round-Trip Engineering	8-24
双向工程	8-24
竞赛	8-26
软件配置	8-28
Version	8-29
版本	8-29
Baseline	8-30
基线	8-30
版本控制	8-31
CM Repository	8-32
配置库	8-32
Check-in	8-33
Check-out	8-33
检出	8-33
检入	8-33
并行开发	8-34
竞赛	8-
测试	9-1
testing	9-1
测试驱动开发	9-2
测试目的	9-3
调试	9-3
debugging	9-3
测试准则	9-4
测试组	9-5
生命周期 测试	9-7
测试 生命周期	9-7
自动化测试	9-7
测试自动化	9-7
单元测试	9-9
缺陷密度	9-12
Defect density	9-12
集成测试	9-14
自顶向下测试	9-16
由底向上测试	9-16
混合方式测试	9-16
一次性集成测试	9-16
Sandwich testing	9-16
确认测试	9-17
有效性测试	9-18
黑盒测试	9-18
配置复查	9-19
系统测试	9-21
Alpha测试	9-21
Beta测试	9-21
α测试	9-21
β测试	9-21
验收测试	9-23
测试技术	9-25
测试覆盖	9-26
覆盖 (测试)	9-26
白盒测试	9-26
黑盒测试	9-34
冒烟测试	9-36
回归测试	9-37
测试过程	9-39
测试计划	9-40
测试因素	9-41
Test Factor	9-41
测试用例	9-42
Test Case	9-42
测试输入	9-42
期望结果	9-42
Test Input	9-42
Expected Result	9-42
缺陷报告	9-43
终止测试	9-45
测试终止	9-45
项目管理	10-1
愚公移山	10-4
软件项目	10-5
项目	10-5
PMBOK	10-6
项目管理知识体系	10-6
费用管理	10-7
综合管理	10-7
成功的标准	10-8
成本管理	10-9
范围管理	10-9
人力资源管理	10-9
时间管理	10-9
质量管理	10-9
采购管理	10-10
风险管理	10-10
沟通管理	10-10
集成管理	10-10
PMBOK	10-12
管理过程	10-12
项目启动	10-13
5W1H	10-13
六拍项目	10-14
启动项目	10-15
立项管理	10-16
自主研发的立项管理	10-17
合同项目的立项管理	10-23
核心开发计划	10-27
支持计划	10-27
WBS	10-28
项目工作细化结构	10-28
工作细化结构	10-28
软件项目计划	10-29
估算	10-30
项目估算	10-30
经验模型	10-31
COCOMO	10-31
经验模型 (估算)	10-31
分工	10-35
结构 (团队)	10-35
团队结构和分工	10-35
Rayleigh-Norden曲线	10-36
Brooks 定律	10-37
布鲁克斯定律	10-37
人员时间权衡定律	10-37
Chief programmer team	10-38
Democratic team	10-38
Hierarchical team	10-38
层次型组织结构	10-38
民主开发小组	10-38
主程序员小组	10-38
人员组织	10-38
项目经理技能	10-40
项目经理职能	10-41
项目经理分级	10-42
实施 (项目)	10-44
项目实施	10-44
监控 (项目)	10-45
项目监控	10-45
项目结束	10-49
收尾 (项目)	10-49
项目收尾	10-49
异常结束	10-50
正常结束	10-50
经验教训	10-51
资产检查	10-51
综合评估	10-51
总结经验教训	10-51
维护	11-3
演化性	11-4
Software Evolution	11-5
Software Maintenance	11-5
软件演化	11-5
维护类型	11-7
维护问题	11-9
维护成本	11-10
维护工作量	11-11
维护无形代价	11-12
维护组织结构图	11-13
维护过程	11-14
可维护性	11-16
可理解性	11-17
可测试性	11-18
可修改性	11-19
可移植性	11-20
Design Recovery	11-24
Refactoring	11-24
Restructuring	11-24
Reverse Engineering	11-24
重构	11-24
逆向工程	11-24
设计恢复	11-24
Reengineering	11-25
再工程	11-25
BPR	11-27
Business Process Reengineering	11-27
业务过程再工程	11-27
再工程过程	11-29
沈备军	每页

